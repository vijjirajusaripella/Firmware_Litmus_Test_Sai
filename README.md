# Firmware Litmus Test ‚Äì Stepper Motor Control using TMC5160 and STM32 (SPI Communication)

## ‚úÖ Project Structure and Design Overview

This firmware is designed for controlling a stepper motor using the TMC5160 driver via SPI communication on an STM32F446RE (NUCLEO) board. The project demonstrates modular embedded system design using asynchronous communication, state machines, and layered architecture.

---

## üìÅ Layered Architecture

My project follows a clean **4-layer architecture** for modularity and maintainability:

| Layer              | Description |
|-------------------|-------------|
| **Application Layer** | Located in main.c/h This Layer manages the state machine logic and reacts to user inputs (User Button Press) to control motor speed and direction through Abstracted API calls. |
| **API Layer**         | `Implemented in api_motor_driver.c/h and api_motor_driver_tmc5160.c/h. It provides a modular and extensible interface to the motor driver. The s_api_motor_driver_t structure defines a generic function-pointer-based interface, enabling easy support for multiple motor driver variants in the future (e.g., adding TMC2209 or other chips requires only a new api_motor_driver_<chip>.c/h pair). This approach isolates motor control logic from low-level hardware specifics, encouraging, reusability, debugging and scalability. |
| **HAL Layer**         | Auto-generated by STM32CubeMX. Includes files like stm32f4xx_hal_spi.c, stm32f4xx_hal_gpio.c, and initializes SPI_HandleTypeDef, GPIO pins, interrupts, etc. Used as the abstraction layer for STM32 hardware access. |
| **Register Layer**    |Embedded within the API layer. The register access is compliant with the TMC5160 datasheet protocol, which requires 40-bit SPI telegrams (8-bit address + 32-bit data). The write function handles address masking and byte shifting as per protocol. |

---

## ‚öôÔ∏è Key Functionalities

- **Asynchronous SPI communication** using `HAL_SPI_Transmit_IT`.
- **State machine-based API design** to prevent blocking delays and allow non-blocking transitions (`initialize`, `set_velocity`, `release_slave`, etc.).
- **Dynamic Velocity Control**:
  - 300 RPM Clockwise ‚Üí Button press 1
  - 500 RPM Counter-Clockwise ‚Üí Button press 2
  - Stop ‚Üí Button press 3 (cycles)
- **User Button (PC13)** triggers RPM transitions.
- **SPI1_CS (PB6)** and **SD_Mode (PA9)** are controlled manually for activating TMC5160 SPI mode and communication window.

---

## üß† Why Asynchronous Communication?

We chose **non-blocking, interrupt-driven SPI communication** (`HAL_SPI_Transmit_IT`) because:

- It avoids halting the main loop during data transfer.
- It makes the firmware scalable and responsive to user actions.
- It aligns with good embedded design practices, especially for real-time control.

---

## üîÅ State Machine Design

All Functions in the Application and API Layers use non-blocking, asynchronous state machines design within a switch-case structure. This allows the function to yield and resume cleanly.

### üìå Example: Application State Machine (`main.c`)

![Image](https://github.com/user-attachments/assets/742466af-db34-4441-878e-5ba8407840e2)

---

## üìå Register Configuration

Only **essential registers** are configured (e.g., `IHOLD_IRUN`, `VACTUAL`, `GSTAT`). Others like `CHOPCONF`, `STEALTHCHOP`, or `PWMCONF` are left at default because:

- The test's goal is to verify basic motor control over SPI, not optimize silent motion or current profiles.
- Simplifies the driver and makes it believable as a student-level demo.

---

## üí° Manual Pin Control

We **manually pull pins low/high** for critical operation steps:

- **SD_Mode (PA9)** ‚Üí Pulled LOW to enable TMC5160 SPI Mode 1
- **SPI1_CS (PB6)** ‚Üí Pulled LOW before SPI transfer and HIGH after

This gives full control over the timing and ensures reliable protocol adherence.

---

## üîå Hardware Configuration

- **MCU**: STM32F446RE (NUCLEO board)
- **Driver**: TMC5160
- **Motor**: Sanyo Denki Stepper (200 steps/rev, 256 microsteps)
- **Communication**: SPI1
- **Button**: PC13 ‚Üí Used to cycle motor speed/direction
- **IDE**: STM32CubeIDE
- 

---
