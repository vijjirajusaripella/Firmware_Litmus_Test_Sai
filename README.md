# Firmware Litmus Test ‚Äì Stepper Motor Control using TMC5160 and STM32 (SPI Communication)

## ‚úÖ Project Structure and Design Overview

This firmware is designed for controlling a stepper motor using the TMC5160 driver via SPI communication on an STM32F446RE (NUCLEO) board. The project demonstrates modular embedded system design using asynchronous communication, state machines, and layered architecture.

---

## üìÅ Layered Architecture

My project follows a clean **4-layer architecture** for modularity and maintainability:

| Layer              | Description |
|-------------------|-------------|
| **Application Layer** | Located in main.c/h This Layer manages the state machine logic and reacts to user inputs (User Button Press) to control motor speed and direction through Abstracted API calls. |
| **API Layer**         | `Implemented in api_motor_driver.c/h and api_motor_driver_tmc5160.c/h. It provides a modular and extensible interface to the motor driver. The s_api_motor_driver_t structure defines a generic function-pointer-based interface, enabling easy support for multiple motor driver variants in the future (e.g., adding TMC2209 or other chips requires only a new api_motor_driver_<chip>.c/h pair). This approach isolates motor control logic from low-level hardware specifics, encouraging, reusability, debugging and scalability. |
| **HAL Layer**         | Auto-generated by STM32CubeMX. Includes files like stm32f4xx_hal_spi.c, stm32f4xx_hal_gpio.c, and initializes SPI_HandleTypeDef, GPIO pins, interrupts, etc. Used as the abstraction layer for STM32 hardware access. |
| **Register Layer**    |Embedded within the API layer. The register access is compliant with the TMC5160 datasheet protocol, which requires 40-bit SPI telegrams (8-bit address + 32-bit data). The write function handles address masking and byte shifting as per protocol. |

---

## ‚öôÔ∏è Key Functionalities

- **Asynchronous SPI communication** using `HAL_SPI_Transmit_IT`.
- **State machine-based API design** to prevent blocking delays and allow non-blocking transitions (`initialize`, `set_velocity` etc.).
- **Dynamic Velocity Control**:
  - 300 RPM Clockwise ‚Üí Button press 1
  - 500 RPM Counter-Clockwise ‚Üí Button press 2
  - Stop ‚Üí Button press 3 (cycles)
- **User Button (PC13)** triggers RPM transitions.
- **SD_Mode (PA9)** to enable the MODE 1 (Fully Featured Motion Controller & Driver) and SPI Communication.
- **SPI_Mode (pin 22 of TMC)** is not considered as i am not using the MODE 2, Mode 3 and UART Communication.
- **SPI1_CS (PB6)** is used to enable or disable the SPI Communication between Microocntroller and TMC5160 Chip.
- **DRR_ENN (PA8)** to enable or diable the motor driver.
---

## üß† Why Asynchronous Communication?

We chose **non-blocking, interrupt-driven SPI communication** (`HAL_SPI_Transmit_IT`) because:

- It avoids halting the main loop during data transfer.
- It makes the firmware scalable and responsive to user actions.
- It aligns with good embedded design practices, especially for real-time control.
- Will be extremely useful if we would like to scale it for other complex tasks.

---

## üîÅ State Machine Design

All Functions in the Application and API Layers use non-blocking, asynchronous state machines design within a switch-case structure. This allows the function to yield and resume cleanly.

### üìå Example: Application State Machine (`main.c`)

![Image](https://github.com/user-attachments/assets/742466af-db34-4441-878e-5ba8407840e2)

---

## üìå Register Configuration

Only **essential registers** are configured (e.g., `IHOLD_IRUN`, `VACTUAL`, `GSTAT`). Others like `CHOPCONF`, `STEALTHCHOP`, or `PWMCONF` are left at default because:

- As the test's goal is to verify basic motor control over SPI, not optimize silent motion or current profiles.
- Simplifies the driver.

---

## üìå TMC5160 Mode Configuration

I chose **Mode 1** for the TMC5160 because it allows standard SPI communication without needing additional signals like STEP/DIR. In this mode, the TMC5160 operates fully via SPI, which suits our microcontroller-based firmware design and gives us complete control over motor configuration and movement.

---

## üí° Manual Pin Control

We **manually pull pins low/high** for critical operation steps:

- **SD_Mode (PA9)** ‚Üí Pulled LOW to enable TMC5160 SPI Mode 1
- **SPI1_CS (PB6)** ‚Üí Pulled LOW before SPI transfer and HIGH after
- **DRV_ENN (PA8)** ‚Üí Pulled LOW to enable the driver

This gives full control over the timing and ensures reliable protocol adherence.

---

## üîå Hardware Configuration

- **MCU**: STM32F446RE (NUCLEO board)
- **Driver**: TMC5160
- **Motor**: Sanyo Denki Stepper (200 steps/rev, 256 microsteps)
- **Communication**: SPI1
- **Button**: PC13 ‚Üí Used to cycle motor speed/direction
- **IDE**: STM32CubeIDE

![Image](https://github.com/user-attachments/assets/ab183b57-9e9a-4de1-9d5e-0164eaba8d7e)


This Connection between the Microcontroller pins and TMC5160 pins as shown below:

| STM32F446RE Pin         | TMC5160 Pin        | Functionality              |
|-------------------|--------------------|----------------------------|
| PA5 (SPI1_SCK)     | SCK(Pin 14)              | SPI Clock                  |
| PA6 (SPI1_MISO)    | SDO (Pin 16)                | Master In, Slave Out       |
| PA7 (SPI1_MOSI)    | SDI (Pin 15)             | Master Out, Slave In       |
| PB6 (SPI1_CS)      | CSN (Pin 13)                | Chip Select to make SPI Communication Active between controller and chip   |
| PA9 (GPIO_Output)  | SD_MODE (Pin 21)           | Selects SPI Mode (LOW)     |
| PA8 (GPIO_Output)             | DRV_ENN (Pin 28)                | To enable the Driver (Low) |
| GND               | GND, GNDA, GNDD              | Common Ground              |
| 3.3V              | VCC_IO (Pin 20)           | Digital IO       |
| 3.3V (or) GND             | SPI_Mode (Pin 22)            | As I am using Mode 1 (Full Featured Motion Controller & Driver), It is not required      |
| PC13 (User_Button)            | -           | Input to change the Motor Direction and Velocity |


- The TMC5160 doesn't drive the motor directly. Instead, it generates gate signals for 8 external MOSFETs arranged as two full H-bridges, one per motor phase as shown in the above figure. The chip outputs signals on HA1/HA2/LA1/LA2 and HB1/HB2/LB1/LB2 which are connected to external gate drivers (like BMA1/BMB1), and those drive the power MOSFETs as shown in the figure. The two coils of the stepper motor are connected across the outputs of these H-bridges as shown in the figure. We used SPI to configure the TMC5160 with velocity and current parameters, and it handles precise microstepping internally.
---
